"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yargs_1 = __importDefault(require("yargs"));
const url_1 = require("url");
const redis_1 = require("./redis");
const package_json_1 = require("../package.json");
const executor_1 = require("./executor");
const colors_1 = require("colors");
const modes = ['redis'];
const cli = yargs_1.default(process.argv.slice(2))
    .version(package_json_1.version)
    .usage("$0 [OPTIONS] [cmd [arg [arg ...]]]")
    .options({
    "host": {
        alias: "h",
        default: "127.0.0.1",
        describe: 'Server hostname (default: 127.0.0.1).',
        type: 'string'
    },
    "port": {
        alias: "p",
        default: 6379,
        describe: "Server port (default: 6379).",
        type: 'number',
    },
    "socket": {
        alias: "s",
        describe: "Server socket (overrides hostname and port).",
        type: 'string'
    },
    "auth": {
        alias: "a",
        describe: "Server password.",
        type: 'string'
    },
    "u": {
        describe: "Server URI.",
        type: 'string'
    },
    "mode": {
        alias: "m",
        describe: "Server Type, only redis available now.",
        choices: modes,
        default: modes[0]
    },
    "cluster": {
        alias: "c",
        describe: "Enable cluster mode (follow -ASK and -MOVED redirections).",
        boolean: true,
        default: false
    },
    "tls": {
        describe: "Establish a secure TLS connection.",
        type: 'boolean',
        default: false
    }
}).parseSync();
const mode = cli.mode;
const cluster = cli.cluster;
const tls = cli.tls;
const tranformFromNumberToString = (arr) => {
    return arr.map((item) => item + "");
};
if (mode.toLowerCase() == 'redis') {
    let redisClient;
    if (cli.s !== undefined) {
        redisClient = new redis_1.GUIRedisClient({ host: cli.socket, cluster, tls });
    }
    else if (cli.u !== undefined) {
        let uri = new url_1.URL(cli.u);
        redisClient = new redis_1.GUIRedisClient({ host: uri.hostname, port: parseInt(uri.port), auth: uri.password, cluster, tls });
    }
    else {
        redisClient = new redis_1.GUIRedisClient({ host: cli.host, port: cli.port, auth: cli.auth, cluster, tls });
    }
    if (cli._ && cli._.length > 0) {
        const callback = (result) => {
            if (result._kind == 'Left') {
                if (result.left instanceof executor_1.RequestEnd) {
                    redisClient.shutdown();
                }
                else if (result.left instanceof executor_1.RedirectError) {
                    if (cluster) {
                        let endpoint = result.left.hostAndPort;
                        let key = result.left.key;
                        let newClient = redisClient.getOrCreateClient(key, endpoint);
                        redisClient.next = colors_1.yellow(result.left.message);
                        redisClient.execute(result.left.commands, callback, newClient);
                    }
                    else {
                        redisClient.next = colors_1.red(`MOVED slot=${result.left.slot} node=${result.left.hostAndPort}`);
                    }
                }
                else {
                    redisClient.next = colors_1.red(result.left.message);
                }
            }
            else {
                let resp = result.right;
                if (Array.isArray(resp)) {
                    for (let item of resp) {
                        redisClient.next = colors_1.green(item);
                    }
                }
                else {
                    redisClient.next = colors_1.green(resp);
                }
            }
        };
        redisClient.execute(tranformFromNumberToString(cli._), callback).then(() => {
            redisClient.shutdown();
        });
    }
    else {
        redisClient.attachEvent();
    }
}
else {
    console.log("Not Support %s Now!", mode);
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GUIRedisClient = exports.__PR__ = void 0;
const redis_1 = require("redis");
const readline_1 = require("readline");
const bluebird_1 = require("bluebird");
const executor_1 = require("./executor");
const s = require('redis-splitargs');
const colors_1 = require("colors");
const buf_1 = require("./buf");
require('core-js/features/array/flat');
require('core-js/features/object/entries');
class PromptResult {
}
class ExitResult {
    constructor(code) {
        this.code = code;
    }
}
exports.__PR__ = new PromptResult();
const __NORMAL_EXIT__ = new ExitResult(0);
const __ABNORMAL_EXIT__ = new ExitResult(-1);
class GUIRedisClient {
    constructor(opt) {
        this.responseCallback = (result) => {
            if (result._kind == 'Left') {
                if (result.left instanceof executor_1.RequestEnd) {
                    this.next = exports.__PR__;
                }
                else if (result.left instanceof executor_1.RedirectError) {
                    if (this.clusterMode) {
                        let endpoint = result.left.hostAndPort;
                        let key = result.left.key;
                        let newClient = this.getOrCreateClient(key, endpoint);
                        this.next = colors_1.yellow(result.left.message);
                        this.execute(result.left.commands, this.responseCallback, newClient);
                    }
                    else {
                        this.next = colors_1.red(`MOVED slot=${result.left.slot} node=${result.left.hostAndPort}`);
                        this.next = exports.__PR__;
                    }
                }
                else {
                    this.next = colors_1.red("(error) " + result.left.message);
                    this.next = exports.__PR__;
                }
            }
            else {
                let resp = result.right;
                if (Array.isArray(resp)) {
                    this.next = resp.map((item) => colors_1.green(item));
                }
                else {
                    this.next = colors_1.green(resp);
                }
            }
        };
        this.clusters = {};
        // the key of keyLocationCache is key stored in the redis,
        // while the value is the cached `host:port`
        this.keyLocationCache = {};
        if (opt.port == undefined) {
            this.defaultNodeName = opt.host;
        }
        else {
            this.defaultNodeName = `${opt.host}:${opt.port}`;
        }
        this.tlsMode = opt.tls;
        this.auth = opt.auth;
        this.clusters[this.defaultNodeName] = this.createRedisClient(this.defaultNodeName);
        this.clusterMode = opt.cluster;
        this.attachRedisEvent(this.defaultClient);
    }
    initReadline() {
        this.rl = readline_1.createInterface(process.stdin, process.stdout);
        this.rl.setPrompt(`${this.defaultNodeName}> `);
        this.rl.prompt();
    }
    attachRedisEvent(client) {
        client.on("end", (_err) => {
            // Exit application when Redis session is ended.
            this.next = __NORMAL_EXIT__;
        });
        client.on("error", (err) => {
            this.next = colors_1.red(`(error) ${err.message}`);
            // Return non-zero value for error.
            this.next = __ABNORMAL_EXIT__;
        });
    }
    execute(commands, callback, client) {
        let c = client !== null && client !== void 0 ? client : this.defaultClient;
        this.executor = executor_1.BaseExecutor.of(c, commands);
        return this.executor.run(callback);
    }
    attachEvent() {
        this.initReadline();
        this.rl.on('line', (line) => {
            this.handleInput(line);
        }).on('close', () => {
            // trigger when `SIGINT` received
            this.next = '\nAbort!';
            this.next = __NORMAL_EXIT__;
        });
    }
    handleInput(line) {
        line = new buf_1.InputBuffer(line).render();
        try {
            let command = line.trim();
            if (command === "") {
                this.next = exports.__PR__;
                return;
            }
            let commands = s(command);
            if (commands.length !== 0) { // we have commands, so process, otherwise just a new prompt
                const CMD = commands.shift().toLowerCase();
                //`exit` and `clear` are not true commands, just part of REPL
                if (CMD === 'exit') {
                    // all connections will be closed after `RedisClient` quit
                    // and an `end` event will be emitted to exit process.
                    if (this.executor)
                        this.executor.shutdown();
                    this.defaultClient.quit();
                }
                else if (CMD === 'clear') {
                    this.next = '\x1b[0f'; /* ANSI clear screen code */
                    readline_1.cursorTo(process.stdout, 0, 0);
                    readline_1.clearScreenDown(process.stdout);
                    this.next = exports.__PR__;
                }
                else {
                    return this.execute([CMD, ...commands], this.responseCallback);
                }
            }
        }
        catch (err) {
            this.next = colors_1.red(`(error) ${err.message}`);
            this.next = exports.__PR__;
        }
    }
    set next(v) {
        if (typeof v === 'string') {
            console.log(v);
        }
        else if (Array.isArray(v)) {
            console.log(v.join("\n"));
        }
        else if (v instanceof PromptResult) {
            this.rl.prompt();
        }
        else if (v instanceof ExitResult) {
            process.exit(v.code);
        }
    }
    get defaultClient() {
        return this.clusters[this.defaultNodeName];
    }
    createRedisClient(redis_url) {
        const protocol = this.tlsMode ? "rediss://" : "redis://";
        let client = redis_1.createClient(protocol + redis_url);
        if (this.auth)
            client.auth(this.auth);
        bluebird_1.promisifyAll(client);
        return client;
    }
    getOrCreateClient(key, server) {
        if (server !== undefined) {
            if (this.clusters[server]) {
                if (key !== undefined)
                    this.keyLocationCache[key] = server;
                return this.clusters[server];
            }
            let client = this.createRedisClient(server);
            client.removeAllListeners();
            client.unref();
            if (key !== undefined) {
                this.keyLocationCache[key] = server;
                this.clusters[server] = client;
            }
            return client;
        }
        if (key !== undefined) {
            let cachedNodeName = this.keyLocationCache[key];
            if (cachedNodeName !== undefined)
                return this.clusters[cachedNodeName];
        }
        return this.defaultClient;
    }
    shutdown() {
        Object.entries(this.clusters).forEach(([_name, client]) => {
            client.removeAllListeners();
            client.quit();
        });
        if (this.rl) {
            this.rl.close();
        }
    }
    get GUIInterface() {
        return this.rl;
    }
}
exports.GUIRedisClient = GUIRedisClient;
